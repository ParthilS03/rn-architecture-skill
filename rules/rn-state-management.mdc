---
name: rn-state-management
description: Governs global state setup strategy
triggers:
  - global state
  - auth state
  - store setup
  - state management
---

# State Management Rules

Before implementing global state, ASK:

"Which state management do you want?

1. **Zustand** — lightweight, minimal boilerplate  
2. **Redux Toolkit** — scalable, devtools, async with thunks"

Then implement only the chosen option.

---

## If Zustand

- **Location**: Store files live in `src/store/` (e.g. `authStore.ts`, `userStore.ts`).
- **Style**: One store per domain; use `create` from `zustand`. Minimal boilerplate — no actions/types files unless the app grows.
- **Pattern**: State + setters in the same slice; optional `persist` middleware for auth token or user preferences.
- **Usage**: Components use `useStore(selector)` or the generated hook; do not put business logic or API calls inside the store unless they are simple one-off updates. For async or API, call services from the component or a small hook that then calls `store.getState().setX(...)`.
- **Auth**: Typical pattern: `authStore` with `token`, `user`, `setAuth`, `clearAuth`; hydrate from secure storage on app init.

Example store shape:

```typescript
// src/store/authStore.ts
import { create } from 'zustand';

interface AuthState {
  token: string | null;
  user: User | null;
  setAuth: (token: string, user: User) => void;
  clearAuth: () => void;
}

export const useAuthStore = create<AuthState>((set) => ({
  token: null,
  user: null,
  setAuth: (token, user) => set({ token, user }),
  clearAuth: () => set({ token: null, user: null }),
}));
```

---

## If Redux Toolkit

- **Structure**: Use **slices** (`createSlice`) for each domain; single store in `src/store/index.ts` (or `store.ts`) with `configureStore`.
- **Async**: Use **createAsyncThunk** (not "crateAsyncThunk") for all async/network work. Handle pending/fulfilled/rejected in the slice with `extraReducers`; no legacy Redux (no hand-written action types, no switch reducers).
- **No legacy Redux**: No `redux`, `redux-thunk`, or `redux-saga` patterns; only Redux Toolkit APIs (`createSlice`, `createAsyncThunk`, `configureStore`).
- **Selectors**: Prefer `createSelector` (Reselect) for derived state; use typed hooks with `useAppDispatch` and `useAppSelector` from a typed `store` export.
- **Auth**: Typical slice: `authSlice` with thunks like `login`, `logout`, `refreshToken`; persist token via middleware or in thunk (e.g. secure storage).

Example pattern:

```typescript
// Slices in src/store/slices/ (e.g. authSlice.ts)
// Async: createAsyncThunk('auth/login', async (payload) => { ... })
// extraReducers: builder.addCase(login.fulfilled, (state, action) => { ... })
```

---

## General

- **Single choice**: Use either Zustand or Redux Toolkit for the app, not both for global state.
- **Screens/components**: Read state via hooks; dispatch or call store setters. Do not duplicate server state in ad-hoc local state when it belongs in the store.
- **Persistence**: Auth token and critical user prefs should be persisted (Zustand `persist` or RTK + middleware); rehydrate on app launch.
